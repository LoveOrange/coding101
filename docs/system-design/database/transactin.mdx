---
sidebar_position: 1
draft: true
---

# 事务

## 1. 为什么要有事务

数据库作为保存数据的组建，很重要的要求，就是要在数据变动的过程中，保证数据的**一致性**与**完整性**：

1. 一致性：数据变动前后，数据的状态要满足业务逻辑的要求，如银行转账时，账户 A 向 B 转账，A 减少的余额应该与 B 增加的余额相同，且不能大于 A 现有的余额。
2. 完整性：数据变动前后，数据的状态要满足预定的约束条件，如主键约束、外键约束等。

为了保证这两个特性，数据库引入了**事务**的概念。

## 2. 事务的定义

事务（Transaction）是包含一系列操作的数据库执行单元，这些操作要么全部执行成功，要么全部执行失败。不存在中间状态。

还是转账的例子，假设账户 A 向账户 B 转账，需要执行以下操作：

1. 检查账户 A 的余额是否足够
2. 如果足够，从账户 A 中减去相应的金额
3. 将相应的金额加到账户 B 中

在执行实际的数据变动时，这些操作就应该放到同一个事务中执行。

## 3. 事务的特性 - ACID

事务有四个重要的特性，用以保障数据的一致性与完整性，

1. 原子性（Atomicity）
2. 一致性（Consistency）
3. 隔离性（Isolation）
4. 持久性（Durability）

下面来分别解释一下这四个特性。

### 3.1. 原子性 Atomicity

原子性要求事务中的所有操作要么全部执行成功，要么全部执行失败。

典型的案例就是转账操作，账户 A 向账户 B 转账，「A 的余额减少」与「B 的余额增加」是两个需要同时执行的操作，如果只执行了其中一个，那么余额就会出现混乱。

在实现上，通常通过日志的方式来实现。事务中的每一次操作都会记录到日志中，如果事务执行失败，可以通过日志来回滚。

### 3.2. 一致性 Consistency

一致性要求事务在执行前后，数据始终保持在正确的状态，既要满足业务逻辑，也需要满足数据库的约束条件。

### 3.3. 隔离性 Isolation

隔离性指事务在执行过程中，其他事务的执行不会影响当前事务。

在实际的生产环境中，对于数据库的读写通常是并发进行的，会存在多个事务对同一张数据表进行操作。

先考虑一个简单的情况，假设事务 A 正在更新记录 r1，事务 B 在更新记录 r2，两个事务不操作同一条记录，理论上两个事务不会有任何影响。

接下来情况稍微复杂了一些，假设事务 A 更新记录 r1，同时事务 B 在查询记录 r1，那么如果事务 A 正在执行中，事务 B 查询到的结果应该是什么样的？

为了解决多个事务同时更新或者查询同一个记录的问题，隔离性又分为了不同的隔离级别，这个在后面会详细介绍。

### 3.4. 持久性 Durability

持久性指事务执行完成后，也可以说事务「提交」后，对数据库会产生永久的改变，数据的状态会持久化到磁盘上。

换个角度讲，数据库的每一次更新，背后对应的就是一个个事务的提交。

## 4. 事务的隔离级别

在 3.3 隔离性中提到，虽然事务的执行是互不影响的，但是在并发环境下还是存在多个事务同时**修改**、**查询**同一条记录的情况。

为了解决这个问题，数据库引入了隔离级别的概念。

### 4.1. 数据库并发读写面临的问题

在讨论隔离级别之前，我们先来思考一下数据库并发读写时可能会遇到的问题。

对于一条记录 r1，假设事务 A 与事务 B 同时对其进行操作，可能面临以下情况：

1. 事务 A 更新 r1 但是**尚未提交**，事务 B 查询到了事务 A **尚未提交**的修改。然后事务 A 回滚或者再一次更新了 r1，此时事务 B 查询到的就是一个事务 A 执行过程中的「脏数据」。这种情况被称为**脏读**。

2. 事务 B 先查询了记录 r1。在事务 B 执行的过程中，事务 A 更新了 r1 的值并提交结束。此时事务 B 又一次查询了记录 r1，由于此时 r1 已经被事务 A 更新，导致事务 B 两次**重复**的查询的结果不一致，这种情况被称为**不可重复读**。

3. 第三种情况类似上一种情况，只不过事务 B 进行的是一个范围查询，查询过程中事务 A 插入了一个新的记录 r2，导致事务 B 第二次查询时多了一条新的记录，就像是出现了幻觉一样，这种情况被称为**幻读**。

### 4.2. 隔离级别

为了解决